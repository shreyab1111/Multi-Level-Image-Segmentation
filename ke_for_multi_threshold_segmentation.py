# -*- coding: utf-8 -*-
"""KE_for_multi-threshold_segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Thl2eusGT5ZfuYo2wt6zBI8dSwEuAPql
"""

#CODE BY: SHREYA BISWAS

!pip install sewar
import cv2
import numpy as np
import random
#from sklearn.metrics import mean_squared_error as mse
from PIL import ImageChops, Image
import matplotlib.path as mpath
import matplotlib.pyplot as plt
import matplotlib as mpl
from skimage import color
from math import log10, sqrt 
import skimage 
from skimage import filters
import math 
from skimage import io
from google.colab.patches import cv2_imshow

from itertools import combinations

def kapur_entropy(h,thresholds,nthrs):
  #COUNTING PIXELS
  cnt = 0
  for i in range(0, len(h)):
    if h[i]>0:
           cnt += h[i]
           
  #FINDING PROBABILITY OF AN INDIVIDUAL PIXEL
  prob=[]
  for i in range (len(h)):
    h[i]=h[i]/cnt
    prob.append(h[i])

  '''KAPUR'S ENTROPY CALCULATION. REFER - https://docs.google.com/document/d/1Rx0Gk9gb65ZSZAmPaSj2c75te8yuxjCPl1PXps1yLdk/edit '''
  ###sum of intensity values for each segment created by threshold MARKED IN PURPLE
  SUM=[]
  SUM.append(sum(h[0:thresholds[0]]))
  
  for i in range(len(thresholds)-1):
    SUM.append(sum(h[thresholds[i]:thresholds[i+1]]))

  SUM.append(sum(h[thresholds[nthrs-1]:256]))  

  #### CALCULATING WO AS MARKED IN BLUE FOR EACH SEGMENT CREATED BY THE THRESHOLDS
  w0=prob[:]
  for k in range(len(thresholds)):
    if(k==0):
      for i in range(0,thresholds[k]):
        w0[i]=w0[i]/SUM[k]
    if(k==len(thresholds)):
      for i in range(thresholds[k-1],256):
        w0[i]=w0[i]/SUM[k]
    else:
      for i in range(thresholds[k-1],thresholds[k]):
        w0[i]=w0[i]/SUM[k]

  ### CALCULATING W1 AS MARKED IN RED FOR EACH SEGMENT CREATED BY THE THRESHOLDS
  w1=prob[:]
  for k in range(len(thresholds)):
    if(k==0):
      for i in range(0,thresholds[k]):
        if w1[i]==0:
          w1[i]=w1[i]
        else:
          w1[i]=math.log(w1[i]/SUM[k])
    if(k==len(thresholds)):
      for i in range(thresholds[k-1],256):
        if w1[i]==0:
          w1[i]=w1[i]
        else:
          w1[i]=math.log(w1[i]/SUM[k])
    else:
      for i in range(thresholds[k-1],thresholds[k]):
        if w1[i]==0:
          w1[i]=w1[i]
        else:
          w1[i]=math.log(abs(w1[i]/SUM[k]))

  ###MULTIPLYING W0 AND W1 AS IN THE FORMULAE
  mul=[]
  for i in range(len(w0)):
    mul.append(w0[i]*w1[i])

  ### GETTING THE SUM OF THE ABOVE MULTIPLIED QUANTITY FOR EACH SEGMENT
  kapur_entropy=[]
  for i in range(len(thresholds)-1):
    kapur_entropy.append(-(sum(mul[thresholds[i]:thresholds[i+1]])))

  #OBJECTIVE FUNCTION 
  J=sum(kapur_entropy)
  #print(J)

  return (J)

def _get_thresholds(hist, nthrs):
    """Get the thresholds that maximize the entropy of the regions
    @param hist: The normalized histogram of the image                 @type hist: ndarray
    @param c_hist: The cummuative normalized histogram of the image    @type c_hist: ndarray
    @param nthrs: The number of thresholds                             @type nthrs: int  """

    # Thresholds combinations
    thr_combinations = combinations(range(255), nthrs)

    max_entropy = 0
    opt_thresholds = None

    for thresholds in thr_combinations:
        # Extending thresholds for convenience
        e_thresholds = [-1]
        e_thresholds.extend(thresholds)
        e_thresholds.extend([len(hist) - 1])

        regions_entropy = kapur_entropy(hist, e_thresholds,nthrs)

        if regions_entropy > max_entropy:
            max_entropy = regions_entropy
            opt_thresholds = thresholds
    return opt_thresholds

def kapur_multithreshold(image, nthrs):
    """ Runs the Kapur's multi-threshold algorithm.
    @param image: The input image               @type image: ndarray
    @param nthrs: The number of thresholds      @type nthrs: int
    @return: The estimated threshold            @rtype: int
    """
    # Histogran
    hist, _ = np.histogram(image, bins=range(256), density=True)

    # Cumulative histogram
    #c_hist = hist.cumsum()

    #return _get_thresholds(hist, c_hist, nthrs)
    return _get_thresholds(hist, nthrs)

def objective(sol,greyscale_img,uniq,region):
        
    out=np.zeros(shape=([len(greyscale_img),len(greyscale_img[0])]))
           
        
    for it in range(0,len(uniq)): # creation of new image
        for j in range(len(region[it][0])):
            out[region[it][0][j]][region[it][1][j]]=sol[it]
                    
    nthrs = 3
    opt_thresholds = kapur_multithreshold(out, nthrs)
    return(opt_thresholds)

def fitness(sol,greyscale_img,uniq,region):
    #value=objective(sol,greyscale_img,uniq,region)
    value=kapur_entropy(greyscale_img)
    print(value)
    return value[0]

def distance(a,b,dim):
    o = np.zeros(dim)
    for i in range(0,len(a)):
        o[i] = abs(a[i] - b[i])
    return o

def Levy(d):
    beta=3/2
    sigma=(math.gamma(1+beta)*math.sin(math.pi*beta/2)/(math.gamma((1+beta)/2)*beta*2**((beta-1)/2)))**(1/beta)
    u=np.random.randn(d)*sigma
    v=np.random.randn(d)
    step=u/abs(v)**(1/beta)
    o=0.01*step
    return o        

img_list=[1]

"""Only KE"""

import os, time, cv2
thresh = [2,3,4,5,6,7]
array = ['/content/drive/MyDrive/standard_test_images/lena_gray_256.tif', '/content/drive/MyDrive/standard_test_images/mandril_gray.tif',
         '/content/drive/MyDrive/standard_test_images/peppers_gray.tif', '/content/drive/MyDrive/standard_test_images/woman_darkhair.tif',
         '/content/drive/MyDrive/standard_test_images/woman_blonde.tif', '/content/drive/MyDrive/standard_test_images/livingroom.tif',
         '/content/drive/MyDrive/standard_test_images/jetplane.tif', '/content/drive/MyDrive/standard_test_images/cameraman.tif']
#img_list = '/content/drive/MyDrive/Dataset/Standard_images_Copy/'
for img_name in array:
  for nthrs in thresh:
    print("Image Name " + str(img_name))
    source = cv2.imread(img_name)
    start = time.time()
    print(kapur_multithreshold(source, nthrs))
    end = time.time()
    print(end-start)
    print('\n')

