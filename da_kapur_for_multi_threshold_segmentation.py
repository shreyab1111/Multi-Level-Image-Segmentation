# -*- coding: utf-8 -*-
"""DA_Kapur for multi-threshold segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K33hwCvtVHipaV0zXECK1TtiJeyZPO2N
"""

# CODE BY: SHREYA BISWAS

!pip install sewar
import cv2
import numpy as np
import random
from PIL import Image
import matplotlib.pyplot as plt
from statsmodels.stats.outliers_influence import variance_inflation_factor
from math import log10, sqrt 
import skimage 
from skimage import filters
import math 
from skimage.metrics import structural_similarity as ssim
from sewar.full_ref import vifp
from skimage import io
from google.colab.patches import cv2_imshow

from itertools import combinations

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

!unzip "/content/drive/MyDrive/archive.zip" -d "/content/drive/MyDrive/Breast DMR-IR/"

def kapur_entropy(h,thresholds,nthrs):
  #COUNTING PIXELS
  cnt = 0
  for i in range(0, len(h)):
    if h[i]>0:
           cnt += h[i]
           
  #FINDING PROBABILITY OF AN INDIVIDUAL PIXEL
  prob=[]
  for i in range (len(h)):
    h[i]=h[i]/cnt
    prob.append(h[i])

  '''KAPUR'S ENTROPY CALCULATION'''
  ###sum of intensity values for each segment created by threshold MARKED IN PURPLE
  SUM=[]
  SUM.append(sum(h[0:thresholds[0]]))
  
  for i in range(len(thresholds)-1):
    SUM.append(sum(h[thresholds[i]:thresholds[i+1]]))

  SUM.append(sum(h[thresholds[nthrs-1]:256]))  

  #### CALCULATING WO AS MARKED IN BLUE FOR EACH SEGMENT CREATED BY THE THRESHOLDS
  w0=prob[:]
  for k in range(len(thresholds)):
    if(k==0):
      for i in range(0,thresholds[k]):
        w0[i]=w0[i]/SUM[k]
    if(k==len(thresholds)):
      for i in range(thresholds[k-1],256):
        w0[i]=w0[i]/SUM[k]
    else:
      for i in range(thresholds[k-1],thresholds[k]):
        w0[i]=w0[i]/SUM[k]

  ### CALCULATING W1 AS MARKED IN RED FOR EACH SEGMENT CREATED BY THE THRESHOLDS
  w1=prob[:]
  for k in range(len(thresholds)):
    if(k==0):
      for i in range(0,thresholds[k]):
        if w1[i]==0:
          w1[i]=w1[i]
        else:
          w1[i]=math.log(w1[i]/SUM[k])
    if(k==len(thresholds)):
      for i in range(thresholds[k-1],256):
        if w1[i]==0:
          w1[i]=w1[i]
        else:
          w1[i]=math.log(w1[i]/SUM[k])
    else:
      for i in range(thresholds[k-1],thresholds[k]):
        if w1[i]==0:
          w1[i]=w1[i]
        else:
          w1[i]=math.log(abs(w1[i]/SUM[k]))

  ###MULTIPLYING W0 AND W1 AS IN THE FORMULAE
  mul=[]
  for i in range(len(w0)):
    mul.append(w0[i]*w1[i])

  ### GETTING THE SUM OF THE ABOVE MULTIPLIED QUANTITY FOR EACH SEGMENT
  kapur_entropy=[]
  for i in range(len(thresholds)-1):
    kapur_entropy.append(-(sum(mul[thresholds[i]:thresholds[i+1]])))

  #OBJECTIVE FUNCTION 
  J=sum(kapur_entropy)
  #print(J)

  return (J)

def fitness(thresholds, greyscale_img,nthrs):
    hist, _ = np.histogram(greyscale_img,bins=range(256), density=True)
    value=kapur_entropy(hist, thresholds,nthrs)
    #print(value)
    return value

def distance(a,b,dim):
    o = np.zeros(dim)
    for i in range(0,len(a)):
        o[i] = abs(a[i] - b[i])
    return o

def Levy(d):
    beta=3/2
    sigma=(math.gamma(1+beta)*math.sin(math.pi*beta/2)/(math.gamma((1+beta)/2)*beta*2**((beta-1)/2)))**(1/beta)
    u=np.random.randn(d)*sigma
    v=np.random.randn(d)
    step=u/abs(v)**(1/beta)
    o=0.01*step
    return o        

def PSNR(original, compressed): 
    mse = np.mean((original - compressed) ** 2) 
    if(mse == 0):  # MSE is zero means no noise is present in the signal. # Therefore PSNR have no importance. 
        return 100
    max_pixel = 255.0
    psnr = 20 * log10(max_pixel / sqrt(mse)) 
    return psnr

psnr=np.zeros(1)
vif=np.zeros(1) #Visual information fidelity
ssim_val=np.zeros(1) #Structural Similarity Index
img_list=[1]

import time,os
threshno = [15]
img_list = '/content/drive/MyDrive/Dataset/Breast Data 02/Sick (Doentes)/'
for img_name in os.listdir(img_list):
  for nthrs in threshno:
    start = time.time()
    print("Image Name " + str(img_name))
    #sr=img_list+img_name 
    sr=img_list+img_name
    source = cv2.imread(sr)
    #cv2_imshow(source) #original image

    greyscale_img = cv2.imread(sr,0)
    #cv2_imshow(greyscale_img) #grayscale image

    gr = cv2.imread(sr,1)
    
    #nthrs = 6 #nthresh+2
    dim=nthrs
    
    ### Parameters

    ub=255
    lb=0
    
    r=(ub-lb)/10
    Delta_max=(ub-lb)/8.5
    
    Food_fitness=0
    Food_pos=np.zeros(dim) #food position
    
    Enemy_fitness=math.inf
    Enemy_pos=np.zeros(dim) #enemy position
    
    population_size=20
    
    fitness_of_X = np.zeros(population_size)
    All_fitness = np.zeros(population_size)

    ### Parameter end 
    
    X = np.zeros(shape=(population_size,dim))
    DeltaX = np.zeros(shape=(population_size,dim))
    
    for i in range(0,population_size):
        for j in range(0,dim):
            X[i][j]=int(lb + random.uniform(0,1)*(ub-lb))
        
        X[i] = np.sort(X[i])
    
    i1=random.randint(0,population_size-1)
    i2=random.randint(0,population_size-1)
    
    ub_del=25
    
    for i in range(0,population_size):
        for j in range(0,dim):
            DeltaX[i][j]=int(lb + random.uniform(0,1)*(ub_del-lb))
        
    Max_iteration=50

    X = X.astype(int)

    for itr in range(1,Max_iteration+1):
        
        r=(ub_del-lb)/4+((ub_del-lb)*(itr/Max_iteration)*2)
        w=0.9-itr*((0.9-0.4)/Max_iteration)
        my_c=0.1-itr*((0.1-0)/(Max_iteration/2))
        
        if my_c<0:
            my_c=0
        
        s=2*random.random()*my_c #separation
        a=2*random.random()*my_c #alignment
        c=2*random.random()*my_c #cohesion
        f=2*random.random()*my_c 
        e=my_c 
        #j=0 
        for i in range(0,population_size):
            fitness_of_X[i] = fitness(X[i],greyscale_img, nthrs)
            All_fitness[i] = fitness_of_X[i]
            
            if fitness_of_X[i] > Food_fitness:
                Food_fitness = fitness_of_X[i]
                #print(Food_fitness)
                Food_pos=X[i]
            
            if fitness_of_X[i] < Enemy_fitness:
                if all((X[i] <= ub)) and all((X[i] >= lb)):
                    #Enemy_fitness = fitness_of_X[i]
                    Enemy_fitness = Food_fitness
                    Enemy_pos = X[i]

            j=j+1
                    
        for i in range(0,population_size):
            index=0
            neighbours_no=0
            
            ### Neighbours position updation
            Neighbours_X = np.zeros(shape=(population_size,dim))
            Neighbours_DeltaX = np.zeros(shape=(population_size,dim))
            
            for j in range(0,population_size):
                Dist2Enemy = distance(X[i],X[j],dim)
                if (all(Dist2Enemy<=r) and all(Dist2Enemy!=0)):
                    index=index+1
                    neighbours_no=neighbours_no+1
                    Neighbours_DeltaX[index]=DeltaX[j]
                    Neighbours_X[index]=X[j]
                    
            #updation of separation cohesion and alignment
            S=np.zeros(dim)           
            if neighbours_no>1:
                for k in range(0,neighbours_no):
                    S=S+(Neighbours_X[k]-X[i])
                S=-S
            else:
                S=np.zeros(dim)
  
            if neighbours_no>1:
                A=(sum(Neighbours_DeltaX))/neighbours_no
            else:
                A = DeltaX[i]
            
            if neighbours_no>1:
                C_temp=(sum(Neighbours_X))/neighbours_no
            else:
                C_temp=X[i]
        
            C=C_temp-X[i]
            
            ###  distance from Food
            Dist2Food=distance(X[i],Food_pos,dim)
                               
            if all(Dist2Food<=r):
                F=Food_pos-X[i]
            else:
                F=np.zeros(dim)

            ### Distance from enemy
            Dist2Enemy=distance(X[i],Enemy_pos,dim)
                               
            if all(Dist2Enemy<=r):
                Enemy=Enemy_pos-X[i]
            else:
                Enemy=np.zeros(dim)

            ### updation of dragonfly position
            for tt in range(0,dim):
                if X[i][tt]>ub:
                    X[i][tt]=ub
                    DeltaX[i][tt]=random.uniform(0,1)*(50-lb)
                    
                if X[i][tt]<lb:
                    X[i][tt]=lb
                    DeltaX[i][tt]=random.uniform(0,1)*(50-lb)
            
            temp=np.zeros(dim)
            Delta_temp=np.zeros(dim)
            
            ### formula in the paper
            if any(Dist2Food>r):
                if neighbours_no>1:
                    for j in range(0,dim):
                        Delta_temp[j] = int(w*DeltaX[i][j] + random.random()*A[j] + random.random()*C[j] + random.random()*S[j])
                        if Delta_temp[j]>Delta_max:
                            Delta_temp[j]=Delta_max
                        if Delta_temp[j]<-Delta_max:
                            Delta_temp[j]=-Delta_max
                        temp[j]=X[i][j]+(Delta_temp[j])
                else:
                    temp=(X[i] + (Levy(dim))*X[i]).astype(int)
                    Delta_temp=np.zeros(dim)
            
            else:
                for j in range(0,dim):
                    Delta_temp[j] = int((a*A[j] + c*C[j] + s*S[j] + f*F[j] + e*Enemy[j]) + w*DeltaX[i][j]) 
                    if Delta_temp[j]>Delta_max:
                        Delta_temp[j]=Delta_max
                    if Delta_temp[j]<-Delta_max:
                        Delta_temp[j]=-Delta_max
                    temp[j]=X[i][j]+Delta_temp[j]

            ### checking the range  
            for j in range(0,dim):
                if temp[j]<lb: # Bringinging back to search space
                        temp[j]=lb
                    
                if temp[j]>ub: # Bringinging back to search space
                    temp[j]=ub
            temp=np.sort(temp)
            Delta_temp=np.sort(Delta_temp)
            temp = temp.astype(int)
            if(fitness(temp,greyscale_img, nthrs)) > fitness_of_X[i]:
                X[i]=temp
                DeltaX[i]=Delta_temp
                             
        Best_score=Food_fitness
        Best_pos=Food_pos
        print(Best_pos)
        print("Iteration = " + str(itr))
    
    best_sol=Best_pos
    print('*****\n')
    print(best_sol)

    end = time.time()
    print(end-start)

    print('end\n\n\n')

def find(thresh):
  path = '/content/Breast Data 02/Sick (Doentes)/P2.png'
  image = cv2.imread(path)
  arr = []
  for t in thresh:
    binary_mask = np.zeros(image.shape)
    for i in range(image.shape[0]):
      for j in range(image.shape[1]):
        for k in range(image.shape[2]):
          if(image[i][j][k]>t):
            binary_mask[i][j][k] = 1
    arr.append(binary_mask)
    res = 0
    for i in range(len(arr)):
      img1 = arr[i]
      res = res+arr[i]
    res = (1.0/len(thresh))*res
    return(res)
    #plt.imshow(res)

path = '/content/Breast Data 02/Sick (Doentes)/P2.png'
image = cv2.imread(path)
arr = []
thresh = threshold[2]
for t in thresh:
  binary_mask = np.zeros(image.shape)
  for i in range(image.shape[0]):
    for j in range(image.shape[1]):
      for k in range(image.shape[2]):
        if(image[i][j][k]>t):
          binary_mask[i][j][k] = 1
  arr.append(binary_mask)

from google.colab.patches import cv2_imshow
res = 0
for i in range(len(arr)):
    img1 = arr[i]
    res = res+arr[i]
res = (1.0/6)*res
plt.imshow(res)

"""Resizing and printing"""

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from skimage import data
from skimage.filters import threshold_multiotsu
import cv2
from google.colab.patches import cv2_imshow

thresholds_list =  [[116],[61, 129],[61, 116, 163],[47,  86, 122, 164],[35,  71, 104, 139 ,172]]

sr='/content/drive/MyDrive/Dataset/Breast Data 02/Sick (Doentes)/P2.png'  # original image from kodak dataset
image = cv2.imread(sr,0)

for thresholds in thresholds_list:
  regions = np.digitize(image, bins=thresholds)
  fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(10, 3.5))
  ax.imshow(regions, cmap='gray')
  plt.savefig('/content/drive/MyDrive/Dataset/Results_Peppers/Otsu'+str(len(thresholds))+'.png')
  ax.axis('off')
  plt.show()

fig = plt.figure(figsize=(15, 10))
rows = 1
columns = 6
for i in range(6):
  if(i<=5):
    Image = cv2.imread('/content/drive/MyDrive/Dataset/Breast Data 02/Sick (Doentes)/P'+str(i+1)+'.png')
    fig.add_subplot(rows, columns,i+1)
    plt.imshow(Image)
    plt.axis('off')