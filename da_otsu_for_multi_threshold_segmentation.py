# -*- coding: utf-8 -*-
"""DA_Otsu for multi-threshold segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SSOgmGzNELDysLZmEQS0qVQRbtvWWkwO
"""

#CODE BY: SHREYA BISWAS

!pip install sewar
import cv2
import numpy as np
import random
from PIL import Image
import matplotlib.pyplot as plt
from math import log10, sqrt 
import skimage 
from skimage import filters
import math 
from skimage import io
from google.colab.patches import cv2_imshow

from itertools import combinations

def otsu_entropy(h,thresholds,nthrs):
  #COUNTING PIXELS
  cnt = 0
  for i in range(0, len(h)):
    if h[i]>0:
           cnt += h[i]
           
  #FINDING PROBABILITY OF AN INDIVIDUAL PIXEL
  prob=[]
  for i in range (len(h)):
    h[i]=h[i]/cnt
    prob.append(h[i])

  '''otsu'S ENTROPY CALCULATION'''

  #### CALCULATING WO AS MARKED IN BLUE FOR EACH SEGMENT CREATED BY THE THRESHOLDS
  w=np.zeros(len(thresholds))
  for k in range(len(thresholds)):
    if(k==0):
      for i in range(0,thresholds[k]):
        w[k]=w[k]+prob[i]
    if(k==len(thresholds)):
      for i in range(thresholds[k-1],256):
        w[k]=w[k]+prob[i]
    else:
      for i in range(thresholds[k-1],thresholds[k]):
        w[k]=w[k]+prob[i]

  meu=np.zeros(len(thresholds))
  for k in range(len(thresholds)):
    if(k==0):
      for i in range(0,thresholds[k]):
        meu[k]=meu[k]+i*prob[i]/w[k]
    if(k==len(thresholds)):
      for i in range(thresholds[k-1],256):
        meu[k]=meu[k]+i*prob[i]/w[k]
    else:
      for i in range(thresholds[k-1],thresholds[k]):
        meu[k]=meu[k]+i*prob[i]/w[k]
  
  meuT = 0
  for k in range(len(thresholds)):
    meuT = meuT+ w[k]*meu[k]
  
  value = 0
  sigma=np.zeros(len(thresholds))
  for k in range(len(thresholds)):
    sigma[k] = (w[k]*(meu[k]-meuT)*(meu[k]-meuT))
    value = value+sigma[k]

  return(value)

def fitness(thresholds, greyscale_img,nthrs):
    hist, _ = np.histogram(greyscale_img,bins=range(256), density=True)
    value=otsu_entropy(hist, thresholds,nthrs)
    #print(value)
    return value

def distance(a,b,dim):
    o = np.zeros(dim)
    for i in range(0,len(a)):
        o[i] = abs(a[i] - b[i])
    return o

def Levy(d):
    beta=3/2
    sigma=(math.gamma(1+beta)*math.sin(math.pi*beta/2)/(math.gamma((1+beta)/2)*beta*2**((beta-1)/2)))**(1/beta)
    u=np.random.randn(d)*sigma
    v=np.random.randn(d)
    step=u/abs(v)**(1/beta)
    o=0.01*step
    return o        

img_list=[1]

import time, os
img_list = '/content/drive/MyDrive/Dataset/Standard_images_Copy/'
for img_name in os.listdir(img_list):
    
    print("Image Name " + str(img_name))
    sr=img_list+img_name
    source = cv2.imread(sr)
    #cv2_imshow(source) #original image

    greyscale_img = cv2.imread(sr,0)
    #cv2_imshow(greyscale_img) #grayscale image

    gr = cv2.imread(sr,1)
    
    nthr = [2,3,4,5,6,7]
    for nthrs in nthr:
      start = time.time()
      dim=nthrs
    
    ### Parameters
    
      ub=255
      lb=0
    
      r=(ub-lb)/10
      Delta_max=(ub-lb)/8.5
    
      Food_fitness=0
      Food_pos=np.zeros(dim) #food position
    
      Enemy_fitness=math.inf
      Enemy_pos=np.zeros(dim) #enemy position
    
      population_size=20
    
      fitness_of_X = np.zeros(population_size)
      All_fitness = np.zeros(population_size)
    
      ### Parameter end 
    
      X = np.zeros(shape=(population_size,dim))
      DeltaX = np.zeros(shape=(population_size,dim))
    
      for i in range(0,population_size):
        for j in range(0,dim):
            X[i][j]=int(lb + random.uniform(0,1)*(ub-lb))
        
        X[i] = np.sort(X[i])
    
      i1=random.randint(0,population_size-1)
      i2=random.randint(0,population_size-1)
    
      ub_del=25
    
      for i in range(0,population_size):
        for j in range(0,dim):
            DeltaX[i][j]=int(lb + random.uniform(0,1)*(ub_del-lb))
        
      Max_iteration=50
    
      X = X.astype(int)
    
      for itr in range(1,Max_iteration+1):
        
        r=(ub_del-lb)/4+((ub_del-lb)*(itr/Max_iteration)*2)
        w=0.9-itr*((0.9-0.4)/Max_iteration)
        my_c=0.1-itr*((0.1-0)/(Max_iteration/2))
        
        if my_c<0:
            my_c=0
        
        s=2*random.random()*my_c #separation
        a=2*random.random()*my_c #alignment
        c=2*random.random()*my_c #cohesion
        f=2*random.random()*my_c 
        e=my_c 
        #j=0 
        for i in range(0,population_size):
            
            fitness_of_X[i] = fitness(X[i],greyscale_img, nthrs)
            All_fitness[i] = fitness_of_X[i]
            
            if fitness_of_X[i] > Food_fitness:
                Food_fitness = fitness_of_X[i]
                #print(Food_fitness)
                Food_pos=X[i]
            
            if fitness_of_X[i] < Enemy_fitness:
                if all((X[i] <= ub)) and all((X[i] >= lb)):
                    #Enemy_fitness = fitness_of_X[i]
                    Enemy_fitness = Food_fitness
                    Enemy_pos = X[i]
    
            j=j+1
                    
        for i in range(0,population_size):
            index=0
            neighbours_no=0
            
            ### Neighbours position updation
            Neighbours_X = np.zeros(shape=(population_size,dim))
            Neighbours_DeltaX = np.zeros(shape=(population_size,dim))
            
            for j in range(0,population_size):
                Dist2Enemy = distance(X[i],X[j],dim)
                if (all(Dist2Enemy<=r) and all(Dist2Enemy!=0)):
                    index=index+1
                    neighbours_no=neighbours_no+1
                    Neighbours_DeltaX[index]=DeltaX[j]
                    Neighbours_X[index]=X[j]
                    
            #updation of separation cohesion and alignment
            S=np.zeros(dim)           
            if neighbours_no>1:
                for k in range(0,neighbours_no):
                    S=S+(Neighbours_X[k]-X[i])
                S=-S
            else:
                S=np.zeros(dim)
  
            if neighbours_no>1:
                A=(sum(Neighbours_DeltaX))/neighbours_no
            else:
                A = DeltaX[i]
            
            if neighbours_no>1:
                C_temp=(sum(Neighbours_X))/neighbours_no
            else:
                C_temp=X[i]
        
            C=C_temp-X[i]
            
            ###  distance from Food
            Dist2Food=distance(X[i],Food_pos,dim)
                               
            if all(Dist2Food<=r):
                F=Food_pos-X[i]
            else:
                F=np.zeros(dim)
    
            ### Distance from enemy
            Dist2Enemy=distance(X[i],Enemy_pos,dim)
                               
            if all(Dist2Enemy<=r):
                Enemy=Enemy_pos-X[i]
            else:
                Enemy=np.zeros(dim)
    
            ### updation of dragonfly position
            for tt in range(0,dim):
                if X[i][tt]>ub:
                    X[i][tt]=ub
                    DeltaX[i][tt]=random.uniform(0,1)*(50-lb)
                    
                if X[i][tt]<lb:
                    X[i][tt]=lb
                    DeltaX[i][tt]=random.uniform(0,1)*(50-lb)
            
            temp=np.zeros(dim)
            Delta_temp=np.zeros(dim)
            
            ### formula in the paper
            if any(Dist2Food>r):
                if neighbours_no>1:
                    for j in range(0,dim):
                        Delta_temp[j] = int(w*DeltaX[i][j] + random.random()*A[j] + random.random()*C[j] + random.random()*S[j])
                        if Delta_temp[j]>Delta_max:
                            Delta_temp[j]=Delta_max
                        if Delta_temp[j]<-Delta_max:
                            Delta_temp[j]=-Delta_max
                        temp[j]=X[i][j]+(Delta_temp[j])
                else:
                    temp=(X[i] + (Levy(dim))*X[i]).astype(int)
                    Delta_temp=np.zeros(dim)
            
            else:
                for j in range(0,dim):
                    Delta_temp[j] = int((a*A[j] + c*C[j] + s*S[j] + f*F[j] + e*Enemy[j]) + w*DeltaX[i][j]) 
                    if Delta_temp[j]>Delta_max:
                        Delta_temp[j]=Delta_max
                    if Delta_temp[j]<-Delta_max:
                        Delta_temp[j]=-Delta_max
                    temp[j]=X[i][j]+Delta_temp[j]
    
            ### checking the range  
            for j in range(0,dim):
                if temp[j]<lb: # Bringinging back to search space
                        temp[j]=lb
                    
                if temp[j]>ub: # Bringinging back to search space
                    temp[j]=ub
            temp=np.sort(temp)
            Delta_temp=np.sort(Delta_temp)
            temp = temp.astype(int)
            if(fitness(temp,greyscale_img, nthrs)) > fitness_of_X[i]:
                X[i]=temp
                DeltaX[i]=Delta_temp
                             
        Best_score=Food_fitness
        Best_pos=Food_pos
        print(Best_pos)
        print("Iteration = " + str(itr))
    
      best_sol=Best_pos
      print('*****\n')
      print(best_sol)

      end = time.time()
      print(end-start)
      print('end\n\n\n')